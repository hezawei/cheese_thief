# 《奶酪大盗》代码实现大纲

> 严格遵循 coding-standards skill 规范：简洁、好读、好改、安全。  
> 不用 emoji，不写死配置，函数不超 100 行，嵌套不超三层。

---

## 一、目录结构（最终版，唯一方案）

```
deskgame/
├── client/                        # 前端（React + Vite + shadcn/ui）
│   ├── public/
│   │   ├── manifest.json
│   │   └── icons/
│   ├── src/
│   │   ├── main.tsx               # 入口，挂载 App
│   │   ├── App.tsx                # 路由定义
│   │   ├── config.ts              # 前端配置（服务器地址等）
│   │   ├── lib/
│   │   │   ├── utils.ts           # cn() 等工具函数
│   │   │   └── socket.ts          # Socket.IO 客户端单例
│   │   ├── hooks/
│   │   │   ├── useGameStore.ts    # Zustand 全局状态
│   │   │   ├── useSocket.ts       # Socket 连接管理
│   │   │   └── useCountdown.ts    # 倒计时 Hook
│   │   ├── components/
│   │   │   ├── ui/                # shadcn/ui 组件（自动生成）
│   │   │   ├── layout/
│   │   │   │   ├── MobileContainer.tsx
│   │   │   │   └── SafeArea.tsx
│   │   │   ├── lobby/
│   │   │   │   ├── CreateRoom.tsx
│   │   │   │   ├── JoinRoom.tsx
│   │   │   │   ├── RoomLobby.tsx
│   │   │   │   └── PlayerSlot.tsx
│   │   │   └── game/
│   │   │       ├── DealingView.tsx
│   │   │       ├── NightView.tsx
│   │   │       ├── NightAction.tsx
│   │   │       ├── AccompliceView.tsx
│   │   │       ├── DayView.tsx
│   │   │       ├── ChatPanel.tsx
│   │   │       ├── VoteView.tsx
│   │   │       ├── ResultView.tsx
│   │   │       ├── DiceRoll.tsx
│   │   │       ├── RoleCard.tsx
│   │   │       ├── CheeseToken.tsx
│   │   │       ├── PlayerAvatar.tsx
│   │   │       └── CountdownBar.tsx
│   │   ├── pages/
│   │   │   ├── HomePage.tsx
│   │   │   ├── LobbyPage.tsx
│   │   │   └── GamePage.tsx
│   │   ├── styles/
│   │   │   └── globals.css
│   │   └── types/
│   │       └── index.ts           # 前端专用类型（引用 shared）
│   ├── index.html
│   ├── vite.config.ts
│   ├── components.json
│   ├── tsconfig.json
│   ├── tsconfig.app.json
│   └── package.json
│   # TailwindCSS v4 不再需要 tailwind.config.ts，配置在 globals.css 的 @theme 中
│
├── server/                        # 后端（Node.js + Express + Socket.IO）
│   ├── src/
│   │   ├── index.ts               # 入口：启动 HTTP + WebSocket
│   │   ├── config.ts              # 后端配置（端口、CORS）
│   │   ├── socket/
│   │   │   ├── index.ts           # Socket.IO 初始化 + 事件注册
│   │   │   ├── roomHandler.ts     # 房间事件处理
│   │   │   └── gameHandler.ts     # 游戏事件处理
│   │   ├── game/
│   │   │   ├── GameEngine.ts      # 游戏引擎（状态机调度）
│   │   │   ├── phases/
│   │   │   │   ├── DealingPhase.ts
│   │   │   │   ├── NightPhase.ts
│   │   │   │   ├── AccomplicePhase.ts
│   │   │   │   ├── DayPhase.ts
│   │   │   │   ├── VotePhase.ts
│   │   │   │   └── ResultPhase.ts
│   │   │   ├── RoomManager.ts     # 全局房间管理
│   │   │   ├── GameRoom.ts        # 单个房间实例
│   │   │   ├── Player.ts          # 玩家实例
│   │   │   └── ViewBuilder.ts     # 个性化视图构建（防作弊）
│   │   └── utils/
│   │       ├── roomCode.ts        # 房间码生成
│   │       ├── shuffle.ts         # 洗牌算法
│   │       └── logger.ts          # 日志工具
│   ├── tsconfig.json
│   └── package.json
│
├── shared/                        # 前后端共享
│   ├── types.ts                   # 数据类型
│   ├── events.ts                  # Socket 事件名
│   ├── constants.ts               # 游戏常量
│   └── rules.ts                   # 人数规则配置表
│
├── .windsurf/
│   └── skills/
│       └── coding-standards/
│           └── SKILL.md
├── 奶酪大盗_完整规则.md
├── 技术设计文档.md
└── 代码实现大纲.md                  # 本文档
```

---

## 二、shared/ 共享层（前后端都引用）

### 2.1 shared/constants.ts

定义所有游戏常量，不写死在业务代码里。

```typescript
// -- 人数限制 --
const MIN_PLAYERS = 4;
const MAX_PLAYERS = 8;

// -- 骰子 --
const DICE_MIN = 1;
const DICE_MAX = 6;

// -- 计时（秒）--
const DEFAULT_NIGHT_ACTION_SECONDS = 8;
const DEFAULT_DAY_DISCUSSION_SECONDS = 180;
const DEFAULT_VOTING_SECONDS = 30;
const DEFAULT_DEALING_DELAY_SECONDS = 3;
const RECONNECT_TIMEOUT_SECONDS = 60;

// -- 房间码 --
const ROOM_CODE_LENGTH = 4;
const ROOM_CODE_CHARSET = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
// 排除了容易混淆的 I/O/0/1
```

这个文件就是纯常量导出，没有逻辑。所有计时、人数限制全部从这读。

### 2.2 shared/types.ts

所有数据结构在这定义一次，前后端共用，避免类型漂移。

```typescript
// ---- 枚举 ----

enum GamePhase {
  LOBBY = 'LOBBY',
  DEALING = 'DEALING',
  NIGHT = 'NIGHT',
  ACCOMPLICE = 'ACCOMPLICE',
  DAY = 'DAY',
  VOTING = 'VOTING',
  RESULT = 'RESULT',
}

enum Role {
  THIEF = 'THIEF',
  SLEEPY = 'SLEEPY',
  SCAPEGOAT = 'SCAPEGOAT',
}

enum Team {
  GOOD = 'GOOD',
  EVIL = 'EVIL',
  NEUTRAL = 'NEUTRAL',
}

// ---- 服务端持有的完整玩家数据 ----

interface ServerPlayer {
  id: string;               // socket id
  name: string;
  avatarIndex: number;
  role: Role;
  diceValues: number[];     // 4人局2个值，其他1个值
  isHost: boolean;
  isAccomplice: boolean;
  isConnected: boolean;
  hasVoted: boolean;
  votedFor: string | null;
  voteCount: number;
  sessionToken: string;     // 断线重连凭证，存客户端 localStorage
}

// ---- 客户端收到的玩家数据（脱敏后）----

interface ClientPlayer {
  id: string;
  name: string;
  avatarIndex: number;
  isHost: boolean;
  isConnected: boolean;
  hasVoted: boolean;
  // 以下字段按权限填充，无权看到的是 null
  role: Role | null;
  diceValues: number[] | null;
  isAccomplice: boolean | null;
  voteCount: number | null;
  votedFor: string | null;
}

// ---- 客户端收到的完整游戏状态 ----

interface ClientGameState {
  roomCode: string;
  phase: GamePhase;
  players: ClientPlayer[];
  settings: GameSettings;
  // 阶段性数据
  night: ClientNightState | null;
  accomplice: ClientAccompliceState | null;
  day: ClientDayState | null;
  vote: ClientVoteState | null;
  result: ClientResultState | null;
}

// ---- 游戏设置 ----

interface GameSettings {
  useScapegoat: boolean;
  nightActionSeconds: number;
  dayDiscussionSeconds: number;
  votingSeconds: number;
}

// ---- 夜晚阶段（客户端视角）----

interface ClientNightState {
  currentDice: number;          // 当前叫到几点（1-6）
  isYourTurn: boolean;          // 是否轮到你
  awakePlayerIds: string[];     // 和你同时醒来的人（仅你醒来时有值）
  canViewDice: boolean;         // 是否可以查看骰子
  viewedDice: ViewedDiceInfo | null; // 查看结果
  cheeseStealVisible: boolean;  // 是否看到有人偷奶酪
  stealerName: string | null;   // 看到谁偷的（仅同醒时可见）
}

interface ViewedDiceInfo {
  targetId: string;
  targetName: string;
  value: number;
}

// ---- 共犯阶段（客户端视角）----

interface ClientAccompliceState {
  // 大盗看到的
  isThiefSelecting: boolean;    // 大盗正在选人
  selectCount: number;          // 需要选几个共犯
  // 共犯看到的
  youAreAccomplice: boolean;    // 你被选为共犯了
  knownThiefId: string | null;  // 你知道的大盗 ID（6/8人局）
  knownThiefName: string | null;
  knownAccompliceIds: string[]; // 你知道的其他共犯（7/8人局）
  knownAccompliceNames: string[];
}

// ---- 白天阶段 ----

interface ClientDayState {
  messages: ChatMessage[];
  remainingSeconds: number;
}

interface ChatMessage {
  id: string;
  playerId: string;
  playerName: string;
  content: string;
  timestamp: number;
}

// ---- 投票阶段 ----

interface ClientVoteState {
  remainingSeconds: number;
  votedCount: number;
  totalCount: number;
  yourVote: string | null;      // 你投了谁
}

// ---- 结算 ----

interface ClientResultState {
  winnerTeam: Team;
  winnerLabel: string;          // "贪睡鼠阵营" / "奶酪大盗阵营" / "背锅鼠"
  revealedPlayers: RevealedPlayer[];
  allPlayers: FullPlayerInfo[];  // 复盘
}

interface RevealedPlayer {
  id: string;
  name: string;
  role: Role;
  voteCount: number;
}

interface FullPlayerInfo {
  id: string;
  name: string;
  role: Role;
  diceValues: number[];
  isAccomplice: boolean;
  voteCount: number;
  votedFor: string | null;
}
```

### 2.3 shared/events.ts

Socket.IO 事件名集中管理，前后端引用同一份，不会拼错。

```typescript
// 客户端发给服务端
const C2S = {
  CREATE_ROOM: 'c2s:createRoom',
  JOIN_ROOM: 'c2s:joinRoom',
  LEAVE_ROOM: 'c2s:leaveRoom',
  RECONNECT: 'c2s:reconnect',
  UPDATE_SETTINGS: 'c2s:updateSettings',
  START_GAME: 'c2s:startGame',
  DEALING_READY: 'c2s:dealingReady',
  NIGHT_ACTION: 'c2s:nightAction',
  ACCOMPLICE_SELECT: 'c2s:accompliceSelect',
  SEND_MESSAGE: 'c2s:sendMessage',
  CAST_VOTE: 'c2s:castVote',
  BACK_TO_LOBBY: 'c2s:backToLobby',
} as const;

// 服务端发给客户端
const S2C = {
  ERROR: 's2c:error',
  ROOM_STATE: 's2c:roomState',        // 广播：房间基本信息
  GAME_STATE: 's2c:gameState',        // 单发：个性化游戏状态
  PHASE_CHANGE: 's2c:phaseChange',    // 广播：阶段切换提示
  NIGHT_PROGRESS: 's2c:nightProgress',// 广播：夜晚当前点数
  NIGHT_YOUR_TURN: 's2c:nightYourTurn',// 单发：轮到你行动
  NIGHT_ACTION_RESULT: 's2c:nightActionResult', // 单发：行动结果
  DAY_NEW_MESSAGE: 's2c:dayNewMessage',// 广播：新聊天消息
  VOTE_UPDATE: 's2c:voteUpdate',       // 广播：投票进度
  GAME_RESULT: 's2c:gameResult',       // 广播：结算结果
  PLAYER_JOINED: 's2c:playerJoined',
  PLAYER_LEFT: 's2c:playerLeft',
  PLAYER_DISCONNECTED: 's2c:playerDisconnected',
  PLAYER_RECONNECTED: 's2c:playerReconnected',
} as const;
```

### 2.4 shared/rules.ts

不同人数下的规则配置表，游戏引擎查这张表做分支。

```typescript
interface PlayerCountRules {
  playerCount: number;
  dicePerPlayer: number;         // 骰子数（4人=2，其他=1）
  sleepyCanViewDice: boolean;    // 贪睡鼠独自醒来能否查看骰子
  hasAccomplicePhase: boolean;   // 是否有共犯指定阶段
  accompliceCount: number;       // 共犯数量（0=看情况自然产生）
  accompliceMethod: 'none' | 'natural' | 'thief_select';
  thiefKnowsAccomplice: boolean;
  accompliceKnowsThief: boolean;
  accomplicesKnowEachOther: boolean;
  canUseScapegoat: boolean;
}

const RULES_BY_PLAYER_COUNT: Record<number, PlayerCountRules> = {
  4: {
    playerCount: 4,
    dicePerPlayer: 2,
    sleepyCanViewDice: false,
    hasAccomplicePhase: false,
    accompliceCount: 0,
    accompliceMethod: 'none',
    thiefKnowsAccomplice: false,
    accompliceKnowsThief: false,
    accomplicesKnowEachOther: false,
    canUseScapegoat: false,
  },
  5: {
    playerCount: 5,
    dicePerPlayer: 1,
    sleepyCanViewDice: true,
    hasAccomplicePhase: false, // 共犯在夜晚阶段自然产生
    accompliceCount: 0,       // 0 表示看运气（0或1）
    accompliceMethod: 'natural',
    thiefKnowsAccomplice: true,
    accompliceKnowsThief: true,
    accomplicesKnowEachOther: false,
    canUseScapegoat: false,
  },
  6: {
    playerCount: 6,
    dicePerPlayer: 1,
    sleepyCanViewDice: true,
    hasAccomplicePhase: true,
    accompliceCount: 1,
    accompliceMethod: 'thief_select',
    thiefKnowsAccomplice: true,
    accompliceKnowsThief: true,
    accomplicesKnowEachOther: false,
    canUseScapegoat: true,
  },
  7: {
    playerCount: 7,
    dicePerPlayer: 1,
    sleepyCanViewDice: true,
    hasAccomplicePhase: true,
    accompliceCount: 2,
    accompliceMethod: 'thief_select',
    thiefKnowsAccomplice: true,
    accompliceKnowsThief: false,   // 7人局特殊：共犯不知道大盗
    accomplicesKnowEachOther: true,
    canUseScapegoat: true,
  },
  8: {
    playerCount: 8,
    dicePerPlayer: 1,
    sleepyCanViewDice: true,
    hasAccomplicePhase: true,
    accompliceCount: 2,
    accompliceMethod: 'thief_select',
    thiefKnowsAccomplice: true,
    accompliceKnowsThief: true,
    accomplicesKnowEachOther: true,
    canUseScapegoat: true,
  },
};
```

这张表是整个游戏逻辑的决策核心。引擎里用 `RULES_BY_PLAYER_COUNT[room.playerCount]` 取规则，不写 if-else 判断人数。

---

## 三、后端各模块实现细节

### 3.1 server/src/index.ts — 入口

职责：创建 Express 实例 + HTTP 服务器 + Socket.IO 实例，注册路由和事件，启动监听。

```
做的事：
1. 读取 config.ts 里的端口和 CORS 配置
2. 创建 express app + http.createServer
3. 创建 Socket.IO server，配置 CORS
4. 调用 socket/index.ts 里的 registerHandlers(io) 注册事件
5. 启动监听，打印日志
```

不到 30 行。

### 3.2 server/src/config.ts — 配置

```typescript
// 全部配置从环境变量读，给默认值
const config = {
  port: parseInt(process.env.PORT || '3001'),
  cors: {
    origin: process.env.CORS_ORIGIN || '*',
  },
};
```

### 3.3 server/src/socket/index.ts — Socket 事件注册

```
做的事：
1. io.on('connection', socket => { ... })
2. 在 connection 回调里注册 roomHandler(io, socket) 和 gameHandler(io, socket)
3. 处理 disconnect 事件
```

只做事件注册的胶水层，不写业务逻辑。

### 3.4 server/src/socket/roomHandler.ts — 房间事件

处理以下事件：

| 事件 | 处理逻辑 |
|------|---------|
| `c2s:createRoom` | 生成房间码 -> 创建 GameRoom -> 把玩家加进去 -> 加入 Socket 房间 -> 回复房间状态 |
| `c2s:joinRoom` | 校验房间存在 + 人数未满 + 阶段是 LOBBY -> 加入 -> 广播更新 |
| `c2s:leaveRoom` | 从房间移除 -> 如果是房主则转移房主 -> 如果房间空了则销毁 |
| `c2s:reconnect` | 用 sessionToken 匹配玩家 -> 恢复 socket 绑定 -> 推送完整状态 |
| `c2s:updateSettings` | 仅房主可操作 -> 更新设置 -> 广播 |

每个处理函数 20-40 行，包含入参校验和错误返回。

### 3.5 server/src/socket/gameHandler.ts — 游戏事件

处理以下事件：

| 事件 | 处理逻辑 |
|------|---------|
| `c2s:startGame` | 仅房主 + LOBBY 阶段 + 人数合法 -> 调用 GameEngine.startGame() |
| `c2s:dealingReady` | 标记该玩家已确认 -> 全部确认后引擎推进到 NIGHT |
| `c2s:nightAction` | 转发给 NightPhase 处理 |
| `c2s:accompliceSelect` | 转发给 AccomplicePhase 处理 |
| `c2s:sendMessage` | 仅 DAY 阶段 -> 校验内容 -> 广播消息 |
| `c2s:castVote` | 转发给 VotePhase 处理 |
| `c2s:backToLobby` | 仅 RESULT 阶段 + 房主 -> 重置房间状态回 LOBBY |

每个函数都是"校验 -> 委托给引擎 -> 引擎内部推送状态"的模式。gameHandler 本身不持有状态。

### 3.6 server/src/game/RoomManager.ts — 全局房间管理

```
职责：
- rooms: Map<string, GameRoom>     // roomCode -> GameRoom
- playerRoomMap: Map<string, string> // socketId -> roomCode
- sessionMap: Map<string, { roomCode, playerId }> // sessionToken -> 位置

方法：
- createRoom(hostName, hostSocket): GameRoom
- joinRoom(roomCode, playerName, socket): GameRoom | Error
- leaveRoom(socketId): void
- getRoom(roomCode): GameRoom | null
- getRoomBySocket(socketId): GameRoom | null
- reconnect(sessionToken, newSocket): GameRoom | null
- destroyRoom(roomCode): void
```

RoomManager 是单例，全局只有一个实例。

### 3.7 server/src/game/GameRoom.ts — 房间实例

```
职责：持有一个房间的全部状态。

属性：
- roomCode: string
- players: ServerPlayer[]
- phase: GamePhase
- settings: GameSettings
- engine: GameEngine              // 每个房间一个引擎实例
- thiefId: string | null
- accompliceIds: string[]
- cheeseStolen: boolean
- nightActions: NightAction[]     // 夜晚行动记录
- messages: ChatMessage[]
- io: Socket.IO Server 引用       // 用于推送

方法：
- addPlayer(name, socket): ServerPlayer
- removePlayer(socketId): void
- getPlayer(id): ServerPlayer | null
- getPlayerBySession(token): ServerPlayer | null
- transferHost(): void            // 房主离开时转移
- resetForNewGame(): void         // 结束后重置（保留玩家）
- broadcastRoomState(): void      // 广播大厅状态（公开信息）
- sendGameState(playerId): void   // 单发个性化游戏状态
- broadcastGameState(): void      // 给每个玩家单发各自的状态
```

### 3.8 server/src/game/Player.ts — 玩家实例

```
纯数据类，对应 ServerPlayer 接口。

构造函数参数：name, socketId
自动生成：sessionToken（uuid v4）、随机 avatarIndex

方法：
- reset(): void  // 新一局时重置角色/骰子/投票等游戏状态，保留 name/avatar
```

### 3.9 server/src/game/ViewBuilder.ts — 视图构建器（防作弊核心）

```
唯一职责：把服务端完整状态转成某个玩家能看到的 ClientGameState。

输入：GameRoom + 目标 playerId
输出：ClientGameState

核心逻辑：
- 遍历 players，对每个玩家构建 ClientPlayer：
  - role: 只有自己的可见，RESULT 阶段全部可见
  - diceValues: 只有自己的 + 夜晚查看过的可见，RESULT 全部可见
  - isAccomplice: 根据人数规则表判断谁对谁可见
  - voteCount: 仅 RESULT 可见
  - votedFor: 仅 RESULT 可见
- 构建各阶段子状态（night/accomplice/day/vote/result）
```

这个模块大概 80-100 行。是安全的关键，必须写得清楚。

### 3.10 server/src/game/GameEngine.ts — 游戏引擎

```
职责：调度各阶段，是状态机的控制中心。

方法：
- startGame(room): void
    1. 查规则表 RULES_BY_PLAYER_COUNT[playerCount]
    2. 生成身份牌（1张大盗 + N张贪睡鼠 + 可选背锅鼠）
    3. Fisher-Yates 洗牌，分配给玩家
    4. 为每个玩家掷骰子
    5. 设置 phase = DEALING
    6. 推送各玩家的 GAME_STATE（每人只看到自己的身份和骰子）

- onAllDealingReady(room): void
    设置 phase = NIGHT，启动 NightPhase.run()

- onNightComplete(room): void
    查规则表 hasAccomplicePhase:
      true -> 启动 AccomplicePhase.run()
      false -> 进入白天 DayPhase.start()

- onAccompliceComplete(room): void
    启动 DayPhase.start()

- onDayComplete(room): void
    设置 phase = VOTING，启动 VotePhase.start()

- onVoteComplete(room): void
    调用 ResultPhase.calculate() 得到结果
    设置 phase = RESULT，广播结果
```

GameEngine 只做调度，不做具体阶段逻辑。每个阶段的逻辑在 phases/ 目录下。

### 3.11 server/src/game/phases/DealingPhase.ts

```
run(room):
  1. 生成角色卡组：
     - roles = [THIEF]
     - 如果 settings.useScapegoat && rules.canUseScapegoat:
         roles += [SCAPEGOAT] + (playerCount - 2) * [SLEEPY]
     - 否则:
         roles += (playerCount - 1) * [SLEEPY]
  2. shuffle(roles)
  3. 分配给 players[i].role = roles[i]
  4. 掷骰子：
     - 4人局：每人 2 颗（随机 1-6 两次，可以重复）
     - 其他：每人 1 颗
  5. 记录 thiefId
  6. phase = DEALING
  7. broadcastGameState()
  8. 等待所有人 dealingReady
```

### 3.12 server/src/game/phases/NightPhase.ts

这是最复杂的阶段，但拆开后每段不超过 50 行。

```
async run(room):
  for dice = 1 to 6:
    // 1. 找到本轮醒来的玩家
    awakePlayers = findAwakePlayers(room, dice)
    // 这里处理 4 人双骰的特殊情况

    // 2. 广播进度
    broadcast NIGHT_PROGRESS { currentDice: dice }

    // 3. 如果没人醒来，等固定时间，继续
    if awakePlayers.length == 0:
      await sleep(nightActionSeconds * 1000)
      continue

    // 4. 判断每个醒来玩家的行动能力
    for player in awakePlayers:
      turnInfo = buildNightTurnInfo(room, player, awakePlayers)
      send NIGHT_YOUR_TURN to player with turnInfo

    // 5. 等待行动（有超时）
    await waitForActions(room, awakePlayers, nightActionSeconds)

    // 6. 处理 5 人局自然产生共犯
    if rules.accompliceMethod == 'natural':
      handleNaturalAccomplice(room, dice, awakePlayers)

  // 夜晚结束，通知引擎
  engine.onNightComplete(room)


findAwakePlayers(room, dice):
  普通局（dicePerPlayer == 1）:
    return players.filter(p => p.diceValues[0] == dice)
  
  4人局（dicePerPlayer == 2）:
    对于大盗：两个点数都可以醒（两次都返回）
    对于贪睡鼠：只能选一个点数醒（客户端在 DEALING 阶段选好了哪个点数）
    所以 4 人局需要额外字段 chosenDice: number


buildNightTurnInfo(room, player, awakePlayers):
  otherAwake = awakePlayers.filter(p => p.id != player.id)
  isAlone = otherAwake.length == 0
  
  if player.role == THIEF:
    return {
      isYourTurn: true,
      awakePlayerIds: otherAwake.map(p => p.id),
      mustStealCheese: true,
      canViewDice: false,
    }
  
  if player.role == SLEEPY || player.role == SCAPEGOAT:
    return {
      isYourTurn: true,
      awakePlayerIds: otherAwake.map(p => p.id),
      mustStealCheese: false,
      canViewDice: isAlone && rules.sleepyCanViewDice,
    }


handleAction(room, playerId, action):
  player = room.getPlayer(playerId)
  
  if action.type == 'VIEW_DICE':
    // 校验：只有独自醒来的贪睡鼠/背锅鼠才能查看
    target = room.getPlayer(action.targetId)
    send NIGHT_ACTION_RESULT to player:
      { targetId, targetName, value: target.diceValues[0] }
    记录到 nightActions
  
  if action.type == 'STEAL_CHEESE':
    // 校验：只有大盗能偷
    room.cheeseStolen = true
    记录到 nightActions


handleNaturalAccomplice(room, dice, awakePlayers):
  // 5 人局：如果大盗和贪睡鼠同一点数醒来
  thief = awakePlayers.find(p => p.role == THIEF)
  if !thief: return  // 大盗不在这一轮
  
  others = awakePlayers.filter(p => p.id != thief.id)
  if others.length == 0: return  // 大盗独自醒来，没有共犯
  
  if others.length == 1:
    // 唯一的同伴自动成为共犯
    others[0].isAccomplice = true
    room.accompliceIds.push(others[0].id)
  else:
    // 多人同醒，大盗需要指一个人
    // 发送选择请求给大盗，等待回复
    await requestThiefSelectAccomplice(room, thief, others, 1)
```

### 3.13 server/src/game/phases/AccomplicePhase.ts

```
async run(room):
  rules = RULES_BY_PLAYER_COUNT[room.playerCount]
  
  // 5 人局共犯已经在夜晚自然产生了，直接跳过
  if rules.accompliceMethod == 'natural':
    engine.onAccompliceComplete(room)
    return
  
  // 6/7/8 人局：大盗主动选人
  selectCount = rules.accompliceCount  // 6人=1, 7人=2, 8人=2
  
  // 1. 通知大盗选人
  send ACCOMPLICE_YOUR_TURN to thief:
    { selectCount, candidateIds: 非大盗的所有玩家 }
  
  // 2. 等待大盗选择（有超时，超时随机选）
  selectedIds = await waitForThiefSelection(room, selectCount)
  
  // 3. 标记共犯
  for id in selectedIds:
    room.getPlayer(id).isAccomplice = true
  room.accompliceIds = selectedIds
  
  // 4. 根据人数规则通知相认
  if rules.accompliceKnowsThief:
    // 6人、8人：共犯知道大盗
    for id in selectedIds:
      send ACCOMPLICE_REVEALED to id:
        { youAreAccomplice: true, thiefName: thief.name, thiefId: thief.id }
  else:
    // 7人：共犯不知道大盗，只知道彼此
    for id in selectedIds:
      otherAccomplices = selectedIds.filter(x => x != id)
      send ACCOMPLICE_REVEALED to id:
        { youAreAccomplice: true, thiefId: null, accompliceNames: [...] }
  
  // 5. 等几秒让大家记住信息
  await sleep(5000)
  
  engine.onAccompliceComplete(room)
```

### 3.14 server/src/game/phases/DayPhase.ts

```
start(room):
  room.phase = DAY
  room.messages = []
  broadcastGameState()
  
  // 启动倒计时
  startCountdown(room.settings.dayDiscussionSeconds, () => {
    engine.onDayComplete(room)
  })

handleMessage(room, playerId, content):
  // 校验：phase == DAY, content 非空且限长（200字）
  msg = {
    id: uuid(),
    playerId,
    playerName: room.getPlayer(playerId).name,
    content: content.trim().substring(0, 200),
    timestamp: Date.now(),
  }
  room.messages.push(msg)
  broadcast DAY_NEW_MESSAGE to room: msg
```

### 3.15 server/src/game/phases/VotePhase.ts

```
start(room):
  room.phase = VOTING
  // 重置投票状态
  for player in room.players:
    player.hasVoted = false
    player.votedFor = null
    player.voteCount = 0
  
  broadcastGameState()
  startCountdown(room.settings.votingSeconds, () => forceEndVoting(room))

handleVote(room, playerId, targetId):
  // 校验：phase == VOTING, 没投过, targetId 不是自己, target 存在
  player = room.getPlayer(playerId)
  player.hasVoted = true
  player.votedFor = targetId
  
  broadcast VOTE_UPDATE: { votedCount, totalCount }
  
  // 检查是否所有人都投了
  if allVoted(room):
    endVoting(room)

endVoting(room):
  // 统计票数
  for player in room.players:
    if player.votedFor:
      room.getPlayer(player.votedFor).voteCount += 1
  
  engine.onVoteComplete(room)

forceEndVoting(room):
  // 超时未投的人，随机投一个（不投自己）
  for player in room.players:
    if !player.hasVoted:
      candidates = room.players.filter(p => p.id != player.id)
      player.votedFor = randomPick(candidates).id
      player.hasVoted = true
  endVoting(room)
```

### 3.16 server/src/game/phases/ResultPhase.ts

```
calculate(room): ClientResultState
  // 1. 找最高票
  maxVotes = max(players.map(p => p.voteCount))
  topPlayers = players.filter(p => p.voteCount == maxVotes)
  
  // 2. 构建被翻牌的玩家列表
  revealed = topPlayers.map(p => ({
    id: p.id,
    name: p.name,
    role: p.role,
    voteCount: p.voteCount,
  }))
  
  // 3. 判断胜负
  winnerTeam = determineWinner(revealed, room.thiefId)
  
  // 4. 构建复盘信息
  allPlayers = room.players.map(p => ({
    id: p.id, name: p.name, role: p.role,
    diceValues: p.diceValues,
    isAccomplice: p.isAccomplice,
    voteCount: p.voteCount,
    votedFor: p.votedFor,
  }))
  
  return { winnerTeam, winnerLabel, revealedPlayers: revealed, allPlayers }


determineWinner(revealed, thiefId): Team
  // 优先级 1：背锅鼠被翻出来 -> 背锅鼠独自赢
  hasScapegoat = revealed.some(p => p.role == SCAPEGOAT)
  if hasScapegoat:
    return NEUTRAL
  
  // 优先级 2：大盗被翻出来 -> 好人赢
  hasThief = revealed.some(p => p.id == thiefId)
  if hasThief:
    return GOOD
  
  // 优先级 3：大盗没被翻出来 -> 坏人赢
  return EVIL
```

---

## 四、前端各模块实现细节

### 4.1 client/src/config.ts

```typescript
const config = {
  serverUrl: import.meta.env.VITE_SERVER_URL || 'http://localhost:3001',
  reconnectAttempts: 5,
  reconnectDelay: 1000,
};
```

开发时连本地 3001，部署时通过环境变量配置。

### 4.2 client/src/lib/socket.ts — Socket 单例

```
创建 Socket.IO 客户端实例，配置自动重连。
导出 socket 单例 + connect/disconnect 函数。
不在这里处理业务事件，只做连接管理。
```

### 4.3 client/src/hooks/useGameStore.ts — Zustand 状态管理

```
这是前端的"唯一数据源"，所有组件从这里读状态。

状态结构：
{
  // 连接状态
  isConnected: boolean,
  
  // 玩家本人信息
  myId: string | null,
  myName: string,
  sessionToken: string | null,  // 存 localStorage

  // 房间信息
  roomCode: string | null,
  
  // 游戏状态（收到 s2c:gameState 后整体替换）
  gameState: ClientGameState | null,
  
  // 夜晚临时状态
  nightViewedDice: ViewedDiceInfo | null,
}

actions:
  setMyName(name)
  setRoomCode(code)
  updateGameState(state)           // 收到服务端推送时调用
  setNightViewedDice(info)
  reset()                          // 回到首页时清空
```

所有服务端推送的数据统一走 `updateGameState`，组件通过 selector 取各自需要的部分。

### 4.4 client/src/hooks/useSocket.ts — Socket 事件监听

```
在 App.tsx 的顶层调用一次。
注册所有 S2C 事件的监听器，把数据写入 useGameStore。
组件卸载时清理监听器。

具体事件映射：
s2c:gameState    -> store.updateGameState(data)
s2c:roomState    -> store.updateGameState(data) 的 lobby 部分
s2c:error        -> toast 提示错误
s2c:nightYourTurn -> store 设置 isMyTurn
s2c:nightActionResult -> store.setNightViewedDice
s2c:dayNewMessage -> 追加到 messages（或由 gameState 携带）
s2c:voteUpdate   -> 更新投票进度
s2c:gameResult   -> store.updateGameState（phase=RESULT）
```

### 4.5 client/src/hooks/useCountdown.ts

```
通用倒计时 hook。
参数：initialSeconds, onComplete
返回：{ remaining, isRunning, start, stop, reset }
内部用 setInterval 每秒递减。
```

### 4.6 client/src/App.tsx — 路由

```tsx
// 用 react-router v7（原 react-router-dom 已合并为 react-router）
<Routes>
  <Route path="/" element={<HomePage />} />
  <Route path="/lobby/:roomCode" element={<LobbyPage />} />
  <Route path="/game/:roomCode" element={<GamePage />} />
</Routes>

// 最外层包裹 MobileContainer
```

### 4.7 client/src/components/layout/MobileContainer.tsx

```
最外层容器。做的事：
1. 限制最大宽度 430px，超出居中显示
2. 高度 100dvh，overflow hidden
3. 安全区域 padding
4. 禁止选中文字、长按菜单
5. 背景色
```

### 4.8 client/src/pages/HomePage.tsx

```
组件结构：
<MobileContainer>
  <div className="flex flex-col items-center justify-center h-full gap-6 px-6">
    {/* 标题区 */}
    <h1>奶酪大盗</h1>
    <p>Cheese Thief</p>
    
    {/* 昵称输入 */}
    <Input placeholder="输入你的昵称" />
    
    {/* 创建房间按钮 */}
    <Button onClick={handleCreate}>创建房间</Button>
    
    {/* 加入房间（展开式） */}
    <Button variant="outline" onClick={toggleJoin}>加入房间</Button>
    {showJoin && (
      <div>
        <Input placeholder="输入房间码" maxLength={4} />
        <Button onClick={handleJoin}>确认加入</Button>
      </div>
    )}
  </div>
</MobileContainer>

交互逻辑：
- 点"创建房间"：emit c2s:createRoom -> 收到回复后 navigate(/lobby/:code)
- 点"确认加入"：emit c2s:joinRoom -> 成功后 navigate(/lobby/:code)
- 昵称保存到 store + localStorage
```

### 4.9 client/src/pages/LobbyPage.tsx

```
组件结构：
<MobileContainer>
  {/* 顶部：房间码 + 复制按钮 */}
  <div>房间: {roomCode} <Button size="sm">复制</Button></div>
  
  {/* 玩家列表 */}
  {players.map(p => <PlayerSlot player={p} />)}
  {/* 空位用虚线占位 */}
  {emptySlots.map(() => <PlayerSlot empty />)}
  
  {/* 设置区（仅房主） */}
  {isHost && <SettingsPanel />}
  
  {/* 开始按钮（仅房主，人数够时可点） */}
  {isHost && <Button disabled={playerCount < 4}>开始游戏</Button>}
</MobileContainer>

SettingsPanel 内容：
- 讨论时间下拉选择：2/3/5 分钟
- 使用背锅鼠开关（6-8人时才显示）
```

### 4.10 client/src/pages/GamePage.tsx

```
根据 gameState.phase 渲染不同的 View 组件：

<MobileContainer>
  {phase === DEALING && <DealingView />}
  {phase === NIGHT && <NightView />}
  {phase === ACCOMPLICE && <AccompliceView />}
  {phase === DAY && <DayView />}
  {phase === VOTING && <VoteView />}
  {phase === RESULT && <ResultView />}
</MobileContainer>

每个 View 组件从 useGameStore 取数据，自己内部再拆子组件。
页面切换用 AnimatePresence 做淡入淡出。
```

### 4.11 game/DealingView.tsx — 发牌

```
分两步展示：
1. 翻开身份卡（RoleCard 组件，Motion rotateY 动画）
2. 掷骰子（DiceRoll 组件，旋转 + 弹跳动画）
3. 显示"你的身份是 XXX，你的点数是 N"
4. "我记住了"按钮 -> emit c2s:dealingReady

4 人局额外：
- 显示两个骰子点数
- 贪睡鼠需要选择用哪个点数醒来
- 大盗不需要选（两个都会醒）
```

### 4.12 game/NightView.tsx — 夜晚

```
判断 isMyTurn:
  false -> 显示"夜晚等待"界面（深色背景，当前点数进度，倒计时）
  true  -> 显示 NightAction 组件

NightAction 组件根据身份和情况分支：
  大盗 -> 显示"你必须偷走奶酪"+ 奶酪消失动画 + 同醒者名单
  贪睡鼠/背锅鼠 独自醒来 -> 显示所有其他玩家骰盅，可选一个查看
  贪睡鼠/背锅鼠 有人同醒 -> 显示同醒者名单 + 提示"你什么都不能做"
  
查看骰子交互：
  点击某个玩家骰盅 -> emit c2s:nightAction { type: VIEW_DICE, targetId }
  收到结果后显示 -> "XX 的骰子是 N 点"
  
超时自动闭眼 -> 服务端处理
```

### 4.13 game/AccompliceView.tsx — 共犯指定

```
分三种视角：

大盗视角（isThief && phase == ACCOMPLICE）:
  显示所有非大盗玩家头像
  可选 selectCount 个人
  确认按钮 -> emit c2s:accompliceSelect { targetIds }

被选为共犯的视角：
  显示"你被选为共犯"
  根据人数规则显示已知信息（大盗是谁 / 其他共犯是谁）

其他人视角：
  显示"请等待..."深色界面
```

### 4.14 game/DayView.tsx — 白天讨论

```
上方：倒计时条（CountdownBar）
中间：聊天消息列表（ChatPanel），自动滚动到底部
下方：输入框 + 发送按钮

ChatPanel:
  每条消息显示：头像 + 昵称 + 内容
  自己的消息靠右，别人的靠左

输入框适配 iOS 键盘：
  用 position: sticky; bottom: 0
  监听 visualViewport resize 事件，调整位置
  这样键盘弹出时输入框不会被遮住
```

### 4.15 game/VoteView.tsx — 投票

```
顶部：倒计时
中间：所有玩家列表（除自己），可选一个
底部：确认投票按钮

投票状态显示：
  未投票 -> 玩家头像正常
  已投票 -> 选中的玩家高亮
  其他人投了但还没揭晓 -> 显示"已投票"标记（不显示投给谁）

进度：已投 X / 共 Y 人

确认投票 -> emit c2s:castVote { targetId }
投完后按钮变灰，显示"等待其他人..."
```

### 4.16 game/ResultView.tsx — 结算

```
分三个区域：

1. 投票结果（票数排名）
   每个玩家显示名字 + 票数
   最高票的人高亮

2. 翻牌动画
   翻开最高票玩家的身份卡（RoleCard 翻转动画）
   显示胜负结果："贪睡鼠阵营获胜" / "奶酪大盗阵营获胜" / "背锅鼠获胜"

3. 复盘区
   展开所有玩家的真实信息：
   名字 | 身份 | 骰子点数 | 共犯标记 | 投给了谁

4. 底部按钮
   房主："返回大厅再来一局"
   非房主："等待房主操作"
```

---

## 五、通用组件实现说明

### 5.1 PlayerAvatar.tsx

```
根据 avatarIndex 显示预设的老鼠头像。
用 shadcn Avatar 组件。
预设 8 个不同颜色/表情的老鼠头像（纯 CSS 或 SVG）。
在线状态：isConnected=false 时灰度显示。
```

### 5.2 RoleCard.tsx

```
props: role, isRevealed, onReveal
正面：身份图案（大盗/贪睡鼠/背锅鼠）
背面：统一的卡背图案
翻转动画：Motion rotateY 从 180 到 0
```

### 5.3 DiceRoll.tsx

```
props: value, isRolling
滚动动画：CSS keyframes，随机旋转 + 弹跳
结束后显示最终点数面
用 CSS 3D transform 模拟骰子六个面
```

### 5.4 CountdownBar.tsx

```
props: total, remaining
顶部横条，宽度 = remaining/total * 100%
颜色随时间变化：绿 -> 黄 -> 红
shadcn Progress 组件改造
```

---

## 六、关键技术实现要点

### 6.1 夜晚阶段的服务端计时

```
用 setTimeout/setInterval 控制每个点数的行动时间。
每个点数开始时启动 timer，到时间自动进入下一点数。
如果玩家提前完成行动，clearTimeout 后立即推进。
注意：所有计时在服务端执行，客户端只做显示倒计时。
```

### 6.2 断线重连完整流程

```
客户端：
1. 首次加入房间时，收到 sessionToken，存 localStorage
2. Socket 断开后自动重连
3. 重连成功后 emit c2s:reconnect { sessionToken, roomCode }
4. 收到完整 gameState，恢复界面

服务端：
1. disconnect 时标记 isConnected = false，不移除玩家
2. 60 秒内收到 c2s:reconnect，恢复绑定
3. 60 秒未重连，移除玩家
4. 如果是夜晚阶段正在等待该玩家行动，超时后自动跳过
```

### 6.3 4 人双骰的特殊处理

```
服务端额外字段：
  ServerPlayer.chosenWakeDice: number | null
  // 贪睡鼠在 DEALING 阶段选的醒来点数

客户端 DealingView：
  4 人局贪睡鼠额外显示选择界面
  "你的两个点数是 2 和 5，选择一个作为醒来点数"
  选择后 emit c2s:dealingReady { chosenDice: 2 }

NightPhase.findAwakePlayers 的 4 人逻辑：
  大盗：diceValues 包含 dice 就醒来
  贪睡鼠/背锅鼠：chosenWakeDice == dice 才醒来
```

### 6.4 iOS 键盘适配（白天聊天）

```
白天讨论的输入框是核心交互区，必须处理好 iOS 键盘弹出问题。

方案：
1. 聊天区域用 flex-1 + overflow-y-auto 占据中间空间
2. 输入框固定在底部（不用 fixed，用 flex 布局自然撑底）
3. 监听 window.visualViewport.resize 事件
4. 键盘弹出时 visualViewport.height 变小
5. 动态调整容器高度 = visualViewport.height
6. 聊天列表自动滚到底部

这样键盘弹出时，整个聊天区域缩小，输入框自然在键盘上方。
```

---

## 七、代码规范检查清单

每个文件写完后对照检查：

| 检查项 | 要求 |
|--------|------|
| 文件里有没有 emoji | 不允许 |
| 函数超过 50 行了没 | 考虑拆分 |
| 函数超过 100 行了没 | 必须拆分 |
| 嵌套超过三层了没 | 提取子函数 |
| 有没有写死的数字/字符串 | 抽到 constants.ts |
| 有没有重复代码 | 提取公共函数 |
| 变量名看得懂不 | 用有意义的名字 |
| 有没有注释掉的代码 | 删掉 |
| 有没有没用的 import | 删掉 |
| 异常有没有被吞掉 | 至少打日志 |
| 配置走配置文件了没 | 不允许硬编码 |
| 修改文件用的什么工具 | 用 IDE edit/multi_edit，不用 PowerShell |

---

## 八、开发顺序（严格按此执行）

```
第 1 步：初始化项目骨架
  - 创建目录结构
  - 初始化 client：vite + react + ts + tailwind + shadcn
  - 初始化 server：node + express + socket.io + ts
  - 创建 shared/ 三个文件
  - 验证前后端各自能启动

第 2 步：全局基础
  - MobileContainer + SafeArea + globals.css（响应式基础）
  - socket.ts 单例 + useSocket hook
  - useGameStore zustand
  - 路由配置

第 3 步：房间系统
  - 后端：RoomManager + roomHandler
  - 前端：HomePage + LobbyPage
  - 联调：创建房间、加入房间、离开房间

第 4 步：发牌阶段
  - 后端：DealingPhase
  - 前端：DealingView + RoleCard + DiceRoll
  - 联调：开始游戏 -> 看到身份和骰子

第 5 步：夜晚阶段
  - 后端：NightPhase（最复杂，分小步）
  - 前端：NightView + NightAction
  - 联调：完整夜晚流程

第 6 步：共犯阶段
  - 后端：AccomplicePhase
  - 前端：AccompliceView
  - 联调：5-8 人各自的共犯流程

第 7 步：白天 + 投票 + 结算
  - 后端：DayPhase + VotePhase + ResultPhase
  - 前端：DayView + VoteView + ResultView
  - 联调：完整游戏流程

第 8 步：4 人特殊规则 + 背锅鼠
  - 双骰逻辑
  - 背锅鼠胜利判定
  - 联调验证

第 9 步：打磨
  - 断线重连
  - 动画优化
  - 各 iOS 机型测试
  - Bug 修复
```

---

*按此大纲执行开发，保证架构方向不跑偏，每一步都有明确的输入输出和职责边界。*
